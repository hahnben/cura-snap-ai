package ai.curasnap.backend.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

/**
 * Service for generating secure, deterministic cache keys using SHA256 hashing.
 * 
 * This service creates consistent cache keys for identical content while ensuring
 * security through salting. Keys are designed to be collision-resistant and
 * provide no information about the original content.
 */
@Component
public class CacheKeyGenerator {

    private static final Logger logger = LoggerFactory.getLogger(CacheKeyGenerator.class);
    
    private static final String HASH_ALGORITHM = "SHA-256";
    private static final String CACHE_KEY_PREFIX = "agent:soap:";
    
    private final String cacheKeySalt;
    
    public CacheKeyGenerator(@Value("${app.agent.cache.key.salt:curasnap-default-salt}") String cacheKeySalt) {
        this.cacheKeySalt = cacheKeySalt;
        logger.info("CacheKeyGenerator initialized with salt length: {}", cacheKeySalt.length());
    }
    
    /**
     * Generates a secure cache key for transcript content.
     * 
     * The key is generated using SHA256 hash of (content + salt) to ensure:
     * - Deterministic: Same content always produces same key
     * - Secure: Salt prevents key prediction attacks
     * - Collision-resistant: SHA256 provides strong collision resistance
     * - No information disclosure: Hash reveals nothing about original content
     * 
     * @param transcript the transcript content to generate a key for
     * @return secure cache key in format "agent:soap:{sha256hash}"
     * @throws IllegalArgumentException if transcript is null or empty
     */
    public String generateCacheKey(String transcript) {
        if (transcript == null || transcript.trim().isEmpty()) {
            throw new IllegalArgumentException("Transcript cannot be null or empty for cache key generation");
        }
        
        try {
            // Normalize transcript content (trim and normalize whitespace)
            String normalizedTranscript = normalizeContent(transcript);
            
            // Create salted content for hashing
            String saltedContent = normalizedTranscript + cacheKeySalt;
            
            // Generate SHA256 hash
            MessageDigest digest = MessageDigest.getInstance(HASH_ALGORITHM);
            byte[] hashBytes = digest.digest(saltedContent.getBytes(StandardCharsets.UTF_8));
            
            // Convert to hexadecimal string
            String hexHash = bytesToHex(hashBytes);
            
            // Return prefixed cache key
            String cacheKey = CACHE_KEY_PREFIX + hexHash;
            
            logger.debug("Generated cache key for transcript content (length: {})", transcript.length());
            
            return cacheKey;
            
        } catch (NoSuchAlgorithmException e) {
            logger.error("SHA-256 algorithm not available for cache key generation", e);
            throw new RuntimeException("Failed to generate cache key: SHA-256 not available", e);
        }
    }
    
    /**
     * Validates if a cache key was generated by this service.
     * 
     * @param cacheKey the cache key to validate
     * @return true if the cache key has the correct format and prefix
     */
    public boolean isValidCacheKey(String cacheKey) {
        if (cacheKey == null) {
            return false;
        }
        
        // Check prefix and length (prefix + 64 hex chars for SHA256)
        return cacheKey.startsWith(CACHE_KEY_PREFIX) 
               && cacheKey.length() == CACHE_KEY_PREFIX.length() + 64
               && cacheKey.substring(CACHE_KEY_PREFIX.length()).matches("[0-9a-f]{64}");
    }
    
    /**
     * Extracts namespace from cache key for debugging purposes.
     * 
     * @param cacheKey the cache key
     * @return the namespace portion (e.g., "agent:soap")
     */
    public String extractNamespace(String cacheKey) {
        if (!isValidCacheKey(cacheKey)) {
            return null;
        }
        
        return CACHE_KEY_PREFIX.substring(0, CACHE_KEY_PREFIX.length() - 1); // Remove trailing ":"
    }
    
    /**
     * Normalizes transcript content for consistent cache key generation.
     * 
     * This ensures that minor variations in whitespace don't result in different
     * cache keys for essentially identical content.
     * 
     * @param transcript the original transcript
     * @return normalized transcript content
     */
    private String normalizeContent(String transcript) {
        return transcript.trim()
                        .replaceAll("\\s+", " ") // Normalize multiple spaces to single space
                        .toLowerCase(); // Case-insensitive caching
    }
    
    /**
     * Converts byte array to hexadecimal string representation.
     * 
     * @param bytes the byte array to convert
     * @return hexadecimal string representation
     */
    private String bytesToHex(byte[] bytes) {
        StringBuilder result = new StringBuilder();
        for (byte b : bytes) {
            result.append(String.format("%02x", b));
        }
        return result.toString();
    }
    
    /**
     * Gets cache key prefix for external services that need to construct cache-related keys.
     * 
     * @return the cache key prefix used by this generator
     */
    public String getCacheKeyPrefix() {
        return CACHE_KEY_PREFIX;
    }
}